3894455d0f107c276a04035e9dc39f70
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  render: true,
  renderHook: true,
  cleanup: true,
  act: true,
  fireEvent: true
};
Object.defineProperty(exports, "act", {
  enumerable: true,
  get: function () {
    return _actCompat.default;
  }
});
exports.cleanup = cleanup;
Object.defineProperty(exports, "fireEvent", {
  enumerable: true,
  get: function () {
    return _fireEvent.fireEvent;
  }
});
exports.render = render;
exports.renderHook = renderHook;
var React = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var ReactDOMClient = _interopRequireWildcard(require("react-dom/client"));
var _dom = require("@testing-library/dom");
Object.keys(_dom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _dom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dom[key];
    }
  });
});
var _actCompat = _interopRequireWildcard(require("./act-compat"));
var _fireEvent = require("./fire-event");
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function jestFakeTimersAreEnabled() {
  /* istanbul ignore else */
  if (typeof jest !== 'undefined' && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true ||
      // modern timers
      // eslint-disable-next-line prefer-object-has-own -- No Object.hasOwn in all target environments we support.
      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    );
  } // istanbul ignore next

  return false;
}
(0, _dom.configure)({
  unstable_advanceTimersWrapper: cb => {
    return (0, _actCompat.default)(cb);
  },
  // We just want to run `waitFor` without IS_REACT_ACT_ENVIRONMENT
  // But that's not necessarily how `asyncWrapper` is used since it's a public method.
  // Let's just hope nobody else is using it.
  asyncWrapper: async cb => {
    const previousActEnvironment = (0, _actCompat.getIsReactActEnvironment)();
    (0, _actCompat.setReactActEnvironment)(false);
    try {
      const result = await cb();
      // Drain microtask queue.
      // Otherwise we'll restore the previous act() environment, before we resolve the `waitFor` call.
      // The caller would have no chance to wrap the in-flight Promises in `act()`
      await new Promise(resolve => {
        setTimeout(() => {
          resolve();
        }, 0);
        if (jestFakeTimersAreEnabled()) {
          jest.advanceTimersByTime(0);
        }
      });
      return result;
    } finally {
      (0, _actCompat.setReactActEnvironment)(previousActEnvironment);
    }
  },
  eventWrapper: cb => {
    let result;
    (0, _actCompat.default)(() => {
      result = cb();
    });
    return result;
  }
});

// Ideally we'd just use a WeakMap where containers are keys and roots are values.
// We use two variables so that we can bail out in constant time when we render with a new container (most common use case)
/**
 * @type {Set<import('react-dom').Container>}
 */
const mountedContainers = new Set();
/**
 * @type Array<{container: import('react-dom').Container, root: ReturnType<typeof createConcurrentRoot>}>
 */
const mountedRootEntries = [];
function createConcurrentRoot(container, {
  hydrate,
  ui,
  wrapper: WrapperComponent
}) {
  let root;
  if (hydrate) {
    (0, _actCompat.default)(() => {
      root = ReactDOMClient.hydrateRoot(container, WrapperComponent ? /*#__PURE__*/React.createElement(WrapperComponent, null, ui) : ui);
    });
  } else {
    root = ReactDOMClient.createRoot(container);
  }
  return {
    hydrate() {
      /* istanbul ignore if */
      if (!hydrate) {
        throw new Error('Attempted to hydrate a non-hydrateable root. This is a bug in `@testing-library/react`.');
      }
      // Nothing to do since hydration happens when creating the root object.
    },
    render(element) {
      root.render(element);
    },
    unmount() {
      root.unmount();
    }
  };
}
function createLegacyRoot(container) {
  return {
    hydrate(element) {
      _reactDom.default.hydrate(element, container);
    },
    render(element) {
      _reactDom.default.render(element, container);
    },
    unmount() {
      _reactDom.default.unmountComponentAtNode(container);
    }
  };
}
function renderRoot(ui, {
  baseElement,
  container,
  hydrate,
  queries,
  root,
  wrapper: WrapperComponent
}) {
  const wrapUiIfNeeded = innerElement => WrapperComponent ? /*#__PURE__*/React.createElement(WrapperComponent, null, innerElement) : innerElement;
  (0, _actCompat.default)(() => {
    if (hydrate) {
      root.hydrate(wrapUiIfNeeded(ui), container);
    } else {
      root.render(wrapUiIfNeeded(ui), container);
    }
  });
  return {
    container,
    baseElement,
    debug: (el = baseElement, maxLength, options) => Array.isArray(el) ?
    // eslint-disable-next-line no-console
    el.forEach(e => console.log((0, _dom.prettyDOM)(e, maxLength, options))) :
    // eslint-disable-next-line no-console,
    console.log((0, _dom.prettyDOM)(el, maxLength, options)),
    unmount: () => {
      (0, _actCompat.default)(() => {
        root.unmount();
      });
    },
    rerender: rerenderUi => {
      renderRoot(wrapUiIfNeeded(rerenderUi), {
        container,
        baseElement,
        root
      });
      // Intentionally do not return anything to avoid unnecessarily complicating the API.
      // folks can use all the same utilities we return in the first place that are bound to the container
    },
    asFragment: () => {
      /* istanbul ignore else (old jsdom limitation) */
      if (typeof document.createRange === 'function') {
        return document.createRange().createContextualFragment(container.innerHTML);
      } else {
        const template = document.createElement('template');
        template.innerHTML = container.innerHTML;
        return template.content;
      }
    },
    ...(0, _dom.getQueriesForElement)(baseElement, queries)
  };
}
function render(ui, {
  container,
  baseElement = container,
  legacyRoot = false,
  queries,
  hydrate = false,
  wrapper
} = {}) {
  if (!baseElement) {
    // default to document.body instead of documentElement to avoid output of potentially-large
    // head elements (such as JSS style blocks) in debug output
    baseElement = document.body;
  }
  if (!container) {
    container = baseElement.appendChild(document.createElement('div'));
  }
  let root;
  // eslint-disable-next-line no-negated-condition -- we want to map the evolution of this over time. The root is created first. Only later is it re-used so we don't want to read the case that happens later first.
  if (!mountedContainers.has(container)) {
    const createRootImpl = legacyRoot ? createLegacyRoot : createConcurrentRoot;
    root = createRootImpl(container, {
      hydrate,
      ui,
      wrapper
    });
    mountedRootEntries.push({
      container,
      root
    });
    // we'll add it to the mounted containers regardless of whether it's actually
    // added to document.body so the cleanup method works regardless of whether
    // they're passing us a custom container or not.
    mountedContainers.add(container);
  } else {
    mountedRootEntries.forEach(rootEntry => {
      // Else is unreachable since `mountedContainers` has the `container`.
      // Only reachable if one would accidentally add the container to `mountedContainers` but not the root to `mountedRootEntries`
      /* istanbul ignore else */
      if (rootEntry.container === container) {
        root = rootEntry.root;
      }
    });
  }
  return renderRoot(ui, {
    container,
    baseElement,
    queries,
    hydrate,
    wrapper,
    root
  });
}
function cleanup() {
  mountedRootEntries.forEach(({
    root,
    container
  }) => {
    (0, _actCompat.default)(() => {
      root.unmount();
    });
    if (container.parentNode === document.body) {
      document.body.removeChild(container);
    }
  });
  mountedRootEntries.length = 0;
  mountedContainers.clear();
}
function renderHook(renderCallback, options = {}) {
  const {
    initialProps,
    ...renderOptions
  } = options;
  const result = /*#__PURE__*/React.createRef();
  function TestComponent({
    renderCallbackProps
  }) {
    const pendingResult = renderCallback(renderCallbackProps);
    React.useEffect(() => {
      result.current = pendingResult;
    });
    return null;
  }
  const {
    rerender: baseRerender,
    unmount
  } = render( /*#__PURE__*/React.createElement(TestComponent, {
    renderCallbackProps: initialProps
  }), renderOptions);
  function rerender(rerenderCallbackProps) {
    return baseRerender( /*#__PURE__*/React.createElement(TestComponent, {
      renderCallbackProps: rerenderCallbackProps
    }));
  }
  return {
    result,
    rerender,
    unmount
  };
}

// just re-export everything from dom-testing-library

/* eslint func-name-matching:0 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwicmVuZGVyIiwicmVuZGVySG9vayIsImNsZWFudXAiLCJhY3QiLCJmaXJlRXZlbnQiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FjdENvbXBhdCIsImRlZmF1bHQiLCJfZmlyZUV2ZW50IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9yZWFjdERvbSIsIlJlYWN0RE9NQ2xpZW50IiwiX2RvbSIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiZSIsIldlYWtNYXAiLCJyIiwidCIsIl9fZXNNb2R1bGUiLCJoYXMiLCJuIiwiX19wcm90b19fIiwiYSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInUiLCJpIiwic2V0IiwiamVzdEZha2VUaW1lcnNBcmVFbmFibGVkIiwiamVzdCIsInNldFRpbWVvdXQiLCJfaXNNb2NrRnVuY3Rpb24iLCJjb25maWd1cmUiLCJ1bnN0YWJsZV9hZHZhbmNlVGltZXJzV3JhcHBlciIsImNiIiwiYXN5bmNXcmFwcGVyIiwicHJldmlvdXNBY3RFbnZpcm9ubWVudCIsImdldElzUmVhY3RBY3RFbnZpcm9ubWVudCIsInNldFJlYWN0QWN0RW52aXJvbm1lbnQiLCJyZXN1bHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFkdmFuY2VUaW1lcnNCeVRpbWUiLCJldmVudFdyYXBwZXIiLCJtb3VudGVkQ29udGFpbmVycyIsIlNldCIsIm1vdW50ZWRSb290RW50cmllcyIsImNyZWF0ZUNvbmN1cnJlbnRSb290IiwiY29udGFpbmVyIiwiaHlkcmF0ZSIsInVpIiwid3JhcHBlciIsIldyYXBwZXJDb21wb25lbnQiLCJyb290IiwiaHlkcmF0ZVJvb3QiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlUm9vdCIsIkVycm9yIiwiZWxlbWVudCIsInVubW91bnQiLCJjcmVhdGVMZWdhY3lSb290IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlclJvb3QiLCJiYXNlRWxlbWVudCIsInF1ZXJpZXMiLCJ3cmFwVWlJZk5lZWRlZCIsImlubmVyRWxlbWVudCIsImRlYnVnIiwiZWwiLCJtYXhMZW5ndGgiLCJvcHRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uc29sZSIsImxvZyIsInByZXR0eURPTSIsInJlcmVuZGVyIiwicmVyZW5kZXJVaSIsImFzRnJhZ21lbnQiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaW5uZXJIVE1MIiwidGVtcGxhdGUiLCJjb250ZW50IiwiZ2V0UXVlcmllc0ZvckVsZW1lbnQiLCJsZWdhY3lSb290IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY3JlYXRlUm9vdEltcGwiLCJwdXNoIiwiYWRkIiwicm9vdEVudHJ5IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwibGVuZ3RoIiwiY2xlYXIiLCJyZW5kZXJDYWxsYmFjayIsImluaXRpYWxQcm9wcyIsInJlbmRlck9wdGlvbnMiLCJjcmVhdGVSZWYiLCJUZXN0Q29tcG9uZW50IiwicmVuZGVyQ2FsbGJhY2tQcm9wcyIsInBlbmRpbmdSZXN1bHQiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiYmFzZVJlcmVuZGVyIiwicmVyZW5kZXJDYWxsYmFja1Byb3BzIl0sInNvdXJjZXMiOlsicHVyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9leHBvcnROYW1lcyA9IHtcbiAgcmVuZGVyOiB0cnVlLFxuICByZW5kZXJIb29rOiB0cnVlLFxuICBjbGVhbnVwOiB0cnVlLFxuICBhY3Q6IHRydWUsXG4gIGZpcmVFdmVudDogdHJ1ZVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFjdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWN0Q29tcGF0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5jbGVhbnVwID0gY2xlYW51cDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpcmVFdmVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZmlyZUV2ZW50LmZpcmVFdmVudDtcbiAgfVxufSk7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMucmVuZGVySG9vayA9IHJlbmRlckhvb2s7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgUmVhY3RET01DbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSk7XG52YXIgX2RvbSA9IHJlcXVpcmUoXCJAdGVzdGluZy1saWJyYXJ5L2RvbVwiKTtcbk9iamVjdC5rZXlzKF9kb20pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9kb21ba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZG9tW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9hY3RDb21wYXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9hY3QtY29tcGF0XCIpKTtcbnZhciBfZmlyZUV2ZW50ID0gcmVxdWlyZShcIi4vZmlyZS1ldmVudFwiKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShlKSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiBudWxsOyB2YXIgciA9IG5ldyBXZWFrTWFwKCksIHQgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlID8gdCA6IHI7IH0pKGUpOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCByKSB7IGlmICghciAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4geyBkZWZhdWx0OiBlIH07IHZhciB0ID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKHIpOyBpZiAodCAmJiB0LmhhcyhlKSkgcmV0dXJuIHQuZ2V0KGUpOyB2YXIgbiA9IHsgX19wcm90b19fOiBudWxsIH0sIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIgdSBpbiBlKSBpZiAoXCJkZWZhdWx0XCIgIT09IHUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbi5kZWZhdWx0ID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuZnVuY3Rpb24gamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnICYmIGplc3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gbGVnYWN5IHRpbWVyc1xuICAgICAgc2V0VGltZW91dC5faXNNb2NrRnVuY3Rpb24gPT09IHRydWUgfHxcbiAgICAgIC8vIG1vZGVybiB0aW1lcnNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItb2JqZWN0LWhhcy1vd24gLS0gTm8gT2JqZWN0Lmhhc093biBpbiBhbGwgdGFyZ2V0IGVudmlyb25tZW50cyB3ZSBzdXBwb3J0LlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldFRpbWVvdXQsICdjbG9jaycpXG4gICAgKTtcbiAgfSAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gIHJldHVybiBmYWxzZTtcbn1cbigwLCBfZG9tLmNvbmZpZ3VyZSkoe1xuICB1bnN0YWJsZV9hZHZhbmNlVGltZXJzV3JhcHBlcjogY2IgPT4ge1xuICAgIHJldHVybiAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KShjYik7XG4gIH0sXG4gIC8vIFdlIGp1c3Qgd2FudCB0byBydW4gYHdhaXRGb3JgIHdpdGhvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UXG4gIC8vIEJ1dCB0aGF0J3Mgbm90IG5lY2Vzc2FyaWx5IGhvdyBgYXN5bmNXcmFwcGVyYCBpcyB1c2VkIHNpbmNlIGl0J3MgYSBwdWJsaWMgbWV0aG9kLlxuICAvLyBMZXQncyBqdXN0IGhvcGUgbm9ib2R5IGVsc2UgaXMgdXNpbmcgaXQuXG4gIGFzeW5jV3JhcHBlcjogYXN5bmMgY2IgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzQWN0RW52aXJvbm1lbnQgPSAoMCwgX2FjdENvbXBhdC5nZXRJc1JlYWN0QWN0RW52aXJvbm1lbnQpKCk7XG4gICAgKDAsIF9hY3RDb21wYXQuc2V0UmVhY3RBY3RFbnZpcm9ubWVudCkoZmFsc2UpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYigpO1xuICAgICAgLy8gRHJhaW4gbWljcm90YXNrIHF1ZXVlLlxuICAgICAgLy8gT3RoZXJ3aXNlIHdlJ2xsIHJlc3RvcmUgdGhlIHByZXZpb3VzIGFjdCgpIGVudmlyb25tZW50LCBiZWZvcmUgd2UgcmVzb2x2ZSB0aGUgYHdhaXRGb3JgIGNhbGwuXG4gICAgICAvLyBUaGUgY2FsbGVyIHdvdWxkIGhhdmUgbm8gY2hhbmNlIHRvIHdyYXAgdGhlIGluLWZsaWdodCBQcm9taXNlcyBpbiBgYWN0KClgXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKGplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICgwLCBfYWN0Q29tcGF0LnNldFJlYWN0QWN0RW52aXJvbm1lbnQpKHByZXZpb3VzQWN0RW52aXJvbm1lbnQpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRXcmFwcGVyOiBjYiA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICByZXN1bHQgPSBjYigpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG4vLyBJZGVhbGx5IHdlJ2QganVzdCB1c2UgYSBXZWFrTWFwIHdoZXJlIGNvbnRhaW5lcnMgYXJlIGtleXMgYW5kIHJvb3RzIGFyZSB2YWx1ZXMuXG4vLyBXZSB1c2UgdHdvIHZhcmlhYmxlcyBzbyB0aGF0IHdlIGNhbiBiYWlsIG91dCBpbiBjb25zdGFudCB0aW1lIHdoZW4gd2UgcmVuZGVyIHdpdGggYSBuZXcgY29udGFpbmVyIChtb3N0IGNvbW1vbiB1c2UgY2FzZSlcbi8qKlxuICogQHR5cGUge1NldDxpbXBvcnQoJ3JlYWN0LWRvbScpLkNvbnRhaW5lcj59XG4gKi9cbmNvbnN0IG1vdW50ZWRDb250YWluZXJzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBAdHlwZSBBcnJheTx7Y29udGFpbmVyOiBpbXBvcnQoJ3JlYWN0LWRvbScpLkNvbnRhaW5lciwgcm9vdDogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlQ29uY3VycmVudFJvb3Q+fT5cbiAqL1xuY29uc3QgbW91bnRlZFJvb3RFbnRyaWVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVDb25jdXJyZW50Um9vdChjb250YWluZXIsIHtcbiAgaHlkcmF0ZSxcbiAgdWksXG4gIHdyYXBwZXI6IFdyYXBwZXJDb21wb25lbnRcbn0pIHtcbiAgbGV0IHJvb3Q7XG4gIGlmIChoeWRyYXRlKSB7XG4gICAgKDAsIF9hY3RDb21wYXQuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgcm9vdCA9IFJlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgV3JhcHBlckNvbXBvbmVudCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJDb21wb25lbnQsIG51bGwsIHVpKSA6IHVpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdChjb250YWluZXIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaHlkcmF0ZSgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoeWRyYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGh5ZHJhdGUgYSBub24taHlkcmF0ZWFibGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBgQHRlc3RpbmctbGlicmFyeS9yZWFjdGAuJyk7XG4gICAgICB9XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIHNpbmNlIGh5ZHJhdGlvbiBoYXBwZW5zIHdoZW4gY3JlYXRpbmcgdGhlIHJvb3Qgb2JqZWN0LlxuICAgIH0sXG5cbiAgICByZW5kZXIoZWxlbWVudCkge1xuICAgICAgcm9vdC5yZW5kZXIoZWxlbWVudCk7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgcm9vdC51bm1vdW50KCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGVnYWN5Um9vdChjb250YWluZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBoeWRyYXRlKGVsZW1lbnQpIHtcbiAgICAgIF9yZWFjdERvbS5kZWZhdWx0Lmh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyKTtcbiAgICB9LFxuICAgIHJlbmRlcihlbGVtZW50KSB7XG4gICAgICBfcmVhY3REb20uZGVmYXVsdC5yZW5kZXIoZWxlbWVudCwgY29udGFpbmVyKTtcbiAgICB9LFxuICAgIHVubW91bnQoKSB7XG4gICAgICBfcmVhY3REb20uZGVmYXVsdC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVuZGVyUm9vdCh1aSwge1xuICBiYXNlRWxlbWVudCxcbiAgY29udGFpbmVyLFxuICBoeWRyYXRlLFxuICBxdWVyaWVzLFxuICByb290LFxuICB3cmFwcGVyOiBXcmFwcGVyQ29tcG9uZW50XG59KSB7XG4gIGNvbnN0IHdyYXBVaUlmTmVlZGVkID0gaW5uZXJFbGVtZW50ID0+IFdyYXBwZXJDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyQ29tcG9uZW50LCBudWxsLCBpbm5lckVsZW1lbnQpIDogaW5uZXJFbGVtZW50O1xuICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgaWYgKGh5ZHJhdGUpIHtcbiAgICAgIHJvb3QuaHlkcmF0ZSh3cmFwVWlJZk5lZWRlZCh1aSksIGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QucmVuZGVyKHdyYXBVaUlmTmVlZGVkKHVpKSwgY29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNvbnRhaW5lcixcbiAgICBiYXNlRWxlbWVudCxcbiAgICBkZWJ1ZzogKGVsID0gYmFzZUVsZW1lbnQsIG1heExlbmd0aCwgb3B0aW9ucykgPT4gQXJyYXkuaXNBcnJheShlbCkgP1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgZWwuZm9yRWFjaChlID0+IGNvbnNvbGUubG9nKCgwLCBfZG9tLnByZXR0eURPTSkoZSwgbWF4TGVuZ3RoLCBvcHRpb25zKSkpIDpcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxcbiAgICBjb25zb2xlLmxvZygoMCwgX2RvbS5wcmV0dHlET00pKGVsLCBtYXhMZW5ndGgsIG9wdGlvbnMpKSxcbiAgICB1bm1vdW50OiAoKSA9PiB7XG4gICAgICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICAgIHJvb3QudW5tb3VudCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICByZXJlbmRlcjogcmVyZW5kZXJVaSA9PiB7XG4gICAgICByZW5kZXJSb290KHdyYXBVaUlmTmVlZGVkKHJlcmVuZGVyVWkpLCB7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYmFzZUVsZW1lbnQsXG4gICAgICAgIHJvb3RcbiAgICAgIH0pO1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBkbyBub3QgcmV0dXJuIGFueXRoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgY29tcGxpY2F0aW5nIHRoZSBBUEkuXG4gICAgICAvLyBmb2xrcyBjYW4gdXNlIGFsbCB0aGUgc2FtZSB1dGlsaXRpZXMgd2UgcmV0dXJuIGluIHRoZSBmaXJzdCBwbGFjZSB0aGF0IGFyZSBib3VuZCB0byB0aGUgY29udGFpbmVyXG4gICAgfSxcblxuICAgIGFzRnJhZ21lbnQ6ICgpID0+IHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIChvbGQganNkb20gbGltaXRhdGlvbikgKi9cbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlUmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGNvbnRhaW5lci5pbm5lckhUTUwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC4uLigwLCBfZG9tLmdldFF1ZXJpZXNGb3JFbGVtZW50KShiYXNlRWxlbWVudCwgcXVlcmllcylcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcih1aSwge1xuICBjb250YWluZXIsXG4gIGJhc2VFbGVtZW50ID0gY29udGFpbmVyLFxuICBsZWdhY3lSb290ID0gZmFsc2UsXG4gIHF1ZXJpZXMsXG4gIGh5ZHJhdGUgPSBmYWxzZSxcbiAgd3JhcHBlclxufSA9IHt9KSB7XG4gIGlmICghYmFzZUVsZW1lbnQpIHtcbiAgICAvLyBkZWZhdWx0IHRvIGRvY3VtZW50LmJvZHkgaW5zdGVhZCBvZiBkb2N1bWVudEVsZW1lbnQgdG8gYXZvaWQgb3V0cHV0IG9mIHBvdGVudGlhbGx5LWxhcmdlXG4gICAgLy8gaGVhZCBlbGVtZW50cyAoc3VjaCBhcyBKU1Mgc3R5bGUgYmxvY2tzKSBpbiBkZWJ1ZyBvdXRwdXRcbiAgICBiYXNlRWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICBjb250YWluZXIgPSBiYXNlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIH1cbiAgbGV0IHJvb3Q7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvbiAtLSB3ZSB3YW50IHRvIG1hcCB0aGUgZXZvbHV0aW9uIG9mIHRoaXMgb3ZlciB0aW1lLiBUaGUgcm9vdCBpcyBjcmVhdGVkIGZpcnN0LiBPbmx5IGxhdGVyIGlzIGl0IHJlLXVzZWQgc28gd2UgZG9uJ3Qgd2FudCB0byByZWFkIHRoZSBjYXNlIHRoYXQgaGFwcGVucyBsYXRlciBmaXJzdC5cbiAgaWYgKCFtb3VudGVkQ29udGFpbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGNyZWF0ZVJvb3RJbXBsID0gbGVnYWN5Um9vdCA/IGNyZWF0ZUxlZ2FjeVJvb3QgOiBjcmVhdGVDb25jdXJyZW50Um9vdDtcbiAgICByb290ID0gY3JlYXRlUm9vdEltcGwoY29udGFpbmVyLCB7XG4gICAgICBoeWRyYXRlLFxuICAgICAgdWksXG4gICAgICB3cmFwcGVyXG4gICAgfSk7XG4gICAgbW91bnRlZFJvb3RFbnRyaWVzLnB1c2goe1xuICAgICAgY29udGFpbmVyLFxuICAgICAgcm9vdFxuICAgIH0pO1xuICAgIC8vIHdlJ2xsIGFkZCBpdCB0byB0aGUgbW91bnRlZCBjb250YWluZXJzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCdzIGFjdHVhbGx5XG4gICAgLy8gYWRkZWQgdG8gZG9jdW1lbnQuYm9keSBzbyB0aGUgY2xlYW51cCBtZXRob2Qgd29ya3MgcmVnYXJkbGVzcyBvZiB3aGV0aGVyXG4gICAgLy8gdGhleSdyZSBwYXNzaW5nIHVzIGEgY3VzdG9tIGNvbnRhaW5lciBvciBub3QuXG4gICAgbW91bnRlZENvbnRhaW5lcnMuYWRkKGNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgbW91bnRlZFJvb3RFbnRyaWVzLmZvckVhY2gocm9vdEVudHJ5ID0+IHtcbiAgICAgIC8vIEVsc2UgaXMgdW5yZWFjaGFibGUgc2luY2UgYG1vdW50ZWRDb250YWluZXJzYCBoYXMgdGhlIGBjb250YWluZXJgLlxuICAgICAgLy8gT25seSByZWFjaGFibGUgaWYgb25lIHdvdWxkIGFjY2lkZW50YWxseSBhZGQgdGhlIGNvbnRhaW5lciB0byBgbW91bnRlZENvbnRhaW5lcnNgIGJ1dCBub3QgdGhlIHJvb3QgdG8gYG1vdW50ZWRSb290RW50cmllc2BcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocm9vdEVudHJ5LmNvbnRhaW5lciA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgIHJvb3QgPSByb290RW50cnkucm9vdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVuZGVyUm9vdCh1aSwge1xuICAgIGNvbnRhaW5lcixcbiAgICBiYXNlRWxlbWVudCxcbiAgICBxdWVyaWVzLFxuICAgIGh5ZHJhdGUsXG4gICAgd3JhcHBlcixcbiAgICByb290XG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgbW91bnRlZFJvb3RFbnRyaWVzLmZvckVhY2goKHtcbiAgICByb290LFxuICAgIGNvbnRhaW5lclxuICB9KSA9PiB7XG4gICAgKDAsIF9hY3RDb21wYXQuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgcm9vdC51bm1vdW50KCk7XG4gICAgfSk7XG4gICAgaWYgKGNvbnRhaW5lci5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuICB9KTtcbiAgbW91bnRlZFJvb3RFbnRyaWVzLmxlbmd0aCA9IDA7XG4gIG1vdW50ZWRDb250YWluZXJzLmNsZWFyKCk7XG59XG5mdW5jdGlvbiByZW5kZXJIb29rKHJlbmRlckNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxQcm9wcyxcbiAgICAuLi5yZW5kZXJPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZXN1bHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gIGZ1bmN0aW9uIFRlc3RDb21wb25lbnQoe1xuICAgIHJlbmRlckNhbGxiYWNrUHJvcHNcbiAgfSkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXN1bHQgPSByZW5kZXJDYWxsYmFjayhyZW5kZXJDYWxsYmFja1Byb3BzKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgcmVzdWx0LmN1cnJlbnQgPSBwZW5kaW5nUmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtcbiAgICByZXJlbmRlcjogYmFzZVJlcmVuZGVyLFxuICAgIHVubW91bnRcbiAgfSA9IHJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGVzdENvbXBvbmVudCwge1xuICAgIHJlbmRlckNhbGxiYWNrUHJvcHM6IGluaXRpYWxQcm9wc1xuICB9KSwgcmVuZGVyT3B0aW9ucyk7XG4gIGZ1bmN0aW9uIHJlcmVuZGVyKHJlcmVuZGVyQ2FsbGJhY2tQcm9wcykge1xuICAgIHJldHVybiBiYXNlUmVyZW5kZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRlc3RDb21wb25lbnQsIHtcbiAgICAgIHJlbmRlckNhbGxiYWNrUHJvcHM6IHJlcmVuZGVyQ2FsbGJhY2tQcm9wc1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3VsdCxcbiAgICByZXJlbmRlcixcbiAgICB1bm1vdW50XG4gIH07XG59XG5cbi8vIGp1c3QgcmUtZXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSBkb20tdGVzdGluZy1saWJyYXJ5XG5cbi8qIGVzbGludCBmdW5jLW5hbWUtbWF0Y2hpbmc6MCAqLyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWixJQUFJQSxzQkFBc0IsR0FBR0MsT0FBTyxDQUFDLDhDQUE4QyxDQUFDO0FBQ3BGQyxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUMzQ0MsS0FBSyxFQUFFO0FBQ1QsQ0FBQyxDQUFDO0FBQ0YsSUFBSUMsWUFBWSxHQUFHO0VBQ2pCQyxNQUFNLEVBQUUsSUFBSTtFQUNaQyxVQUFVLEVBQUUsSUFBSTtFQUNoQkMsT0FBTyxFQUFFLElBQUk7RUFDYkMsR0FBRyxFQUFFLElBQUk7RUFDVEMsU0FBUyxFQUFFO0FBQ2IsQ0FBQztBQUNEVCxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLEtBQUssRUFBRTtFQUNwQ1EsVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVk7SUFDZixPQUFPQyxVQUFVLENBQUNDLE9BQU87RUFDM0I7QUFDRixDQUFDLENBQUM7QUFDRlgsT0FBTyxDQUFDSyxPQUFPLEdBQUdBLE9BQU87QUFDekJQLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsV0FBVyxFQUFFO0VBQzFDUSxVQUFVLEVBQUUsSUFBSTtFQUNoQkMsR0FBRyxFQUFFLFNBQUFBLENBQUEsRUFBWTtJQUNmLE9BQU9HLFVBQVUsQ0FBQ0wsU0FBUztFQUM3QjtBQUNGLENBQUMsQ0FBQztBQUNGUCxPQUFPLENBQUNHLE1BQU0sR0FBR0EsTUFBTTtBQUN2QkgsT0FBTyxDQUFDSSxVQUFVLEdBQUdBLFVBQVU7QUFDL0IsSUFBSVMsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ2pCLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyRCxJ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