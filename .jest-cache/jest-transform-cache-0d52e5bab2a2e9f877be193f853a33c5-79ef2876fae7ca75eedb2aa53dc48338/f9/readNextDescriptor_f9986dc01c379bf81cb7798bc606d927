2701c006652e997150097a8e5f1089ac
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var bracketDict;
(function (bracketDict) {
  bracketDict['{'] = '}';
  bracketDict['['] = ']';
})(bracketDict || (bracketDict = {}));
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */
function readNextDescriptor(text, context) {
  let pos = 0;
  const startBracket = text[pos] in bracketDict ? text[pos] : '';
  pos += startBracket.length;
  const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
  const type = isEscapedChar ? '' : startBracket;
  return {
    type,
    ...(type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context))
  };
}
function readPrintableChar(text, pos, context) {
  const descriptor = text[pos];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  const releasePreviousModifier = text[pos] === '/' ? '/' : '';
  pos += releasePreviousModifier.length;
  const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
  pos += Number(escapedDescriptor);
  const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  var _text_slice_match_;
  const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';
  pos += repeatModifier.length;
  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
  pos += releaseSelfModifier.length;
  const expectedEndBracket = bracketDict[startBracket];
  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
  if (!endBracket) {
    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `"${expectedEndBracket}"`].filter(Boolean).join(' or '), text[pos], text, context));
  }
  pos += endBracket.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: !!releasePreviousModifier,
    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
  };
}
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor) {
    throw new Error(getErrorMessage('key descriptor', text[pos], text, context));
  }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier) {
    return releaseSelfModifier === '/';
  }
  if (repeatModifier) {
    return false;
  }
}
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found !== null && found !== void 0 ? found : ''}" in "${text}"
    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}
exports.readNextDescriptor = readNextDescriptor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJyYWNrZXREaWN0IiwicmVhZE5leHREZXNjcmlwdG9yIiwidGV4dCIsImNvbnRleHQiLCJwb3MiLCJzdGFydEJyYWNrZXQiLCJsZW5ndGgiLCJpc0VzY2FwZWRDaGFyIiwiUmVnRXhwIiwidGVzdCIsInR5cGUiLCJyZWFkUHJpbnRhYmxlQ2hhciIsInJlYWRUYWciLCJkZXNjcmlwdG9yIiwiYXNzZXJ0RGVzY3JpcHRvciIsImNvbnN1bWVkTGVuZ3RoIiwicmVsZWFzZVByZXZpb3VzIiwicmVsZWFzZVNlbGYiLCJyZXBlYXQiLCJfdGV4dF9zbGljZV9tYXRjaCIsIl90ZXh0X3NsaWNlX21hdGNoMSIsInJlbGVhc2VQcmV2aW91c01vZGlmaWVyIiwiZXNjYXBlZERlc2NyaXB0b3IiLCJOdW1iZXIiLCJzbGljZSIsIm1hdGNoIiwiX3RleHRfc2xpY2VfbWF0Y2hfIiwicmVwZWF0TW9kaWZpZXIiLCJyZWxlYXNlU2VsZk1vZGlmaWVyIiwiZXhwZWN0ZWRFbmRCcmFja2V0IiwiZW5kQnJhY2tldCIsIkVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJNYXRoIiwibWF4Iiwic3Vic3RyIiwiaGFzUmVsZWFzZVNlbGYiLCJleHBlY3RlZCIsImZvdW5kIl0sInNvdXJjZXMiOlsicmVhZE5leHREZXNjcmlwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJyYWNrZXREaWN0O1xuKGZ1bmN0aW9uKGJyYWNrZXREaWN0KSB7XG4gICAgYnJhY2tldERpY3RbJ3snXSA9ICd9JztcbiAgICBicmFja2V0RGljdFsnWyddID0gJ10nO1xufSkoYnJhY2tldERpY3QgfHwgKGJyYWNrZXREaWN0ID0ge30pKTtcbi8qKlxuICogUmVhZCB0aGUgbmV4dCBrZXkgZGVmaW5pdGlvbiBmcm9tIHVzZXIgaW5wdXRcbiAqXG4gKiBEZXNjcmliZSBrZXkgcGVyIGB7ZGVzY3JpcHRvcn1gIG9yIGBbZGVzY3JpcHRvcl1gLlxuICogRXZlcnl0aGluZyBlbHNlIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYSBzaW5nbGUgY2hhcmFjdGVyIGFzIGRlc2NyaXB0b3IgLSBlLmcuIGBhYC5cbiAqIEJyYWNrZXRzIGB7YCBhbmQgYFtgIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIC0gZS5nLiBgZm9vW1tiYXJgIHRyYW5zbGF0ZXMgdG8gYGZvb1tiYXJgLlxuICogQSBwcmV2aW91c2x5IHByZXNzZWQga2V5IGNhbiBiZSByZWxlYXNlZCBwZXIgYHsvZGVzY3JpcHRvcn1gLlxuICogS2VlcGluZyB0aGUga2V5IHByZXNzZWQgY2FuIGJlIHdyaXR0ZW4gYXMgYHtkZXNjcmlwdG9yPn1gLlxuICogV2hlbiBrZWVwaW5nIHRoZSBrZXkgcHJlc3NlZCB5b3UgY2FuIGNob29zZSBob3cgbG9uZyB0aGUga2V5IGlzIHByZXNzZWQgYHtkZXNjcmlwdG9yPjN9YC5cbiAqIFlvdSBjYW4gdGhlbiByZWxlYXNlIHRoZSBrZXkgcGVyIGB7ZGVzY3JpcHRvcj4zL31gIG9yIGtlZXAgaXQgcHJlc3NlZCBhbmQgY29udGludWUgd2l0aCB0aGUgbmV4dCBrZXkuXG4gKi8gZnVuY3Rpb24gcmVhZE5leHREZXNjcmlwdG9yKHRleHQsIGNvbnRleHQpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBzdGFydEJyYWNrZXQgPSB0ZXh0W3Bvc10gaW4gYnJhY2tldERpY3QgPyB0ZXh0W3Bvc10gOiAnJztcbiAgICBwb3MgKz0gc3RhcnRCcmFja2V0Lmxlbmd0aDtcbiAgICBjb25zdCBpc0VzY2FwZWRDaGFyID0gbmV3IFJlZ0V4cChgXlxcXFwke3N0YXJ0QnJhY2tldH17Mn1gKS50ZXN0KHRleHQpO1xuICAgIGNvbnN0IHR5cGUgPSBpc0VzY2FwZWRDaGFyID8gJycgOiBzdGFydEJyYWNrZXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgLi4udHlwZSA9PT0gJycgPyByZWFkUHJpbnRhYmxlQ2hhcih0ZXh0LCBwb3MsIGNvbnRleHQpIDogcmVhZFRhZyh0ZXh0LCBwb3MsIHR5cGUsIGNvbnRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRQcmludGFibGVDaGFyKHRleHQsIHBvcywgY29udGV4dCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0ZXh0W3Bvc107XG4gICAgYXNzZXJ0RGVzY3JpcHRvcihkZXNjcmlwdG9yLCB0ZXh0LCBwb3MsIGNvbnRleHQpO1xuICAgIHBvcyArPSBkZXNjcmlwdG9yLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZExlbmd0aDogcG9zLFxuICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICByZWxlYXNlUHJldmlvdXM6IGZhbHNlLFxuICAgICAgICByZWxlYXNlU2VsZjogdHJ1ZSxcbiAgICAgICAgcmVwZWF0OiAxXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRUYWcodGV4dCwgcG9zLCBzdGFydEJyYWNrZXQsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RleHRfc2xpY2VfbWF0Y2gsIF90ZXh0X3NsaWNlX21hdGNoMTtcbiAgICBjb25zdCByZWxlYXNlUHJldmlvdXNNb2RpZmllciA9IHRleHRbcG9zXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgcG9zICs9IHJlbGVhc2VQcmV2aW91c01vZGlmaWVyLmxlbmd0aDtcbiAgICBjb25zdCBlc2NhcGVkRGVzY3JpcHRvciA9IHN0YXJ0QnJhY2tldCA9PT0gJ3snICYmIHRleHRbcG9zXSA9PT0gJ1xcXFwnO1xuICAgIHBvcyArPSBOdW1iZXIoZXNjYXBlZERlc2NyaXB0b3IpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBlc2NhcGVkRGVzY3JpcHRvciA/IHRleHRbcG9zXSA6IChfdGV4dF9zbGljZV9tYXRjaCA9IHRleHQuc2xpY2UocG9zKS5tYXRjaChzdGFydEJyYWNrZXQgPT09ICd7JyA/IC9eXFx3K3xeW159Pi9dLyA6IC9eXFx3Ky8pKSA9PT0gbnVsbCB8fCBfdGV4dF9zbGljZV9tYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RleHRfc2xpY2VfbWF0Y2hbMF07XG4gICAgYXNzZXJ0RGVzY3JpcHRvcihkZXNjcmlwdG9yLCB0ZXh0LCBwb3MsIGNvbnRleHQpO1xuICAgIHBvcyArPSBkZXNjcmlwdG9yLmxlbmd0aDtcbiAgICB2YXIgX3RleHRfc2xpY2VfbWF0Y2hfO1xuICAgIGNvbnN0IHJlcGVhdE1vZGlmaWVyID0gKF90ZXh0X3NsaWNlX21hdGNoXyA9IChfdGV4dF9zbGljZV9tYXRjaDEgPSB0ZXh0LnNsaWNlKHBvcykubWF0Y2goL14+XFxkKy8pKSA9PT0gbnVsbCB8fCBfdGV4dF9zbGljZV9tYXRjaDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90ZXh0X3NsaWNlX21hdGNoMVswXSkgIT09IG51bGwgJiYgX3RleHRfc2xpY2VfbWF0Y2hfICE9PSB2b2lkIDAgPyBfdGV4dF9zbGljZV9tYXRjaF8gOiAnJztcbiAgICBwb3MgKz0gcmVwZWF0TW9kaWZpZXIubGVuZ3RoO1xuICAgIGNvbnN0IHJlbGVhc2VTZWxmTW9kaWZpZXIgPSB0ZXh0W3Bvc10gPT09ICcvJyB8fCAhcmVwZWF0TW9kaWZpZXIgJiYgdGV4dFtwb3NdID09PSAnPicgPyB0ZXh0W3Bvc10gOiAnJztcbiAgICBwb3MgKz0gcmVsZWFzZVNlbGZNb2RpZmllci5sZW5ndGg7XG4gICAgY29uc3QgZXhwZWN0ZWRFbmRCcmFja2V0ID0gYnJhY2tldERpY3Rbc3RhcnRCcmFja2V0XTtcbiAgICBjb25zdCBlbmRCcmFja2V0ID0gdGV4dFtwb3NdID09PSBleHBlY3RlZEVuZEJyYWNrZXQgPyBleHBlY3RlZEVuZEJyYWNrZXQgOiAnJztcbiAgICBpZiAoIWVuZEJyYWNrZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTWVzc2FnZShbXG4gICAgICAgICAgICAhcmVwZWF0TW9kaWZpZXIgJiYgJ3JlcGVhdCBtb2RpZmllcicsXG4gICAgICAgICAgICAhcmVsZWFzZVNlbGZNb2RpZmllciAmJiAncmVsZWFzZSBtb2RpZmllcicsXG4gICAgICAgICAgICBgXCIke2V4cGVjdGVkRW5kQnJhY2tldH1cImBcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignIG9yICcpLCB0ZXh0W3Bvc10sIHRleHQsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcG9zICs9IGVuZEJyYWNrZXQubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoOiBwb3MsXG4gICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgIHJlbGVhc2VQcmV2aW91czogISFyZWxlYXNlUHJldmlvdXNNb2RpZmllcixcbiAgICAgICAgcmVwZWF0OiByZXBlYXRNb2RpZmllciA/IE1hdGgubWF4KE51bWJlcihyZXBlYXRNb2RpZmllci5zdWJzdHIoMSkpLCAxKSA6IDEsXG4gICAgICAgIHJlbGVhc2VTZWxmOiBoYXNSZWxlYXNlU2VsZihyZWxlYXNlU2VsZk1vZGlmaWVyLCByZXBlYXRNb2RpZmllcilcbiAgICB9O1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVzY3JpcHRvcihkZXNjcmlwdG9yLCB0ZXh0LCBwb3MsIGNvbnRleHQpIHtcbiAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTWVzc2FnZSgna2V5IGRlc2NyaXB0b3InLCB0ZXh0W3Bvc10sIHRleHQsIGNvbnRleHQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNSZWxlYXNlU2VsZihyZWxlYXNlU2VsZk1vZGlmaWVyLCByZXBlYXRNb2RpZmllcikge1xuICAgIGlmIChyZWxlYXNlU2VsZk1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiByZWxlYXNlU2VsZk1vZGlmaWVyID09PSAnLyc7XG4gICAgfVxuICAgIGlmIChyZXBlYXRNb2RpZmllcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCwgdGV4dCwgY29udGV4dCkge1xuICAgIHJldHVybiBgRXhwZWN0ZWQgJHtleHBlY3RlZH0gYnV0IGZvdW5kIFwiJHtmb3VuZCAhPT0gbnVsbCAmJiBmb3VuZCAhPT0gdm9pZCAwID8gZm91bmQgOiAnJ31cIiBpbiBcIiR7dGV4dH1cIlxuICAgIFNlZSAke2NvbnRleHQgPT09ICdwb2ludGVyJyA/IGBodHRwczovL3Rlc3RpbmctbGlicmFyeS5jb20vZG9jcy91c2VyLWV2ZW50L3BvaW50ZXIjcHJlc3NpbmctYS1idXR0b24tb3ItdG91Y2hpbmctdGhlLXNjcmVlbmAgOiBgaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL2RvY3MvdXNlci1ldmVudC9rZXlib2FyZGB9XG4gICAgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IHVzZXJFdmVudCBwYXJzZXMgeW91ciBpbnB1dC5gO1xufVxuXG5leHBvcnRzLnJlYWROZXh0RGVzY3JpcHRvciA9IHJlYWROZXh0RGVzY3JpcHRvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFBRUMsS0FBSyxFQUFFO0FBQUssQ0FBQyxDQUFDO0FBRTdELElBQUlDLFdBQVc7QUFDZixDQUFDLFVBQVNBLFdBQVcsRUFBRTtFQUNuQkEsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7RUFDdEJBLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHO0FBQzFCLENBQUMsRUFBRUEsV0FBVyxLQUFLQSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUksU0FBU0Msa0JBQWtCQSxDQUFDQyxJQUFJLEVBQUVDLE9B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